;1.1 Что выведут следующие выражения,

10 ;10

(+ 5 3 4) ;12

(- 9 1) ;8

(/ 6 2) ;3

(+ (* 5 5) (- 4 8)) ;21

(define a 3) ;3

(define b (+ a 1)) ;4

(+ a b (* b a)) ;19

(= a b)  ;#false

(if (and (> b a) (< b (* a b)))
      b
      a) ;4

(cond ((= a 4) 6)
      ((= b 4) (+ 1 7 a))
      (else 25)) ;12

(+ 2 (if (< b a) b a)) ;5

(* (cond((> a b) a)
        ((< a b) b)
        (else -1))
        (+ a 2)) ;20



;1.2 Перевести выражение в префиксную форму

(/ (+ 5 4 
        (- 2 
            (- 3 
                (+ 5 
                    (/ 4 5))))) 
    (* 3 
        (- 6 2) (- 2 7))) ; -0.23



;1.3 Определите процедуру, которая приниает в качестве аргументов три числа
; и возвращает сумму квадратов двух больших из них.

(define square (lambda (x) (* x x)))

(square 2)

(define max-square-value-sum (lambda (a b c) (
    cond ( (and (< a b) (< a c)) (+ (square b) (square c)) )
         ( (and (< b a) (< b c)) (+ (square a) (square c)) )
         (else (+ (square a) (square b)))))
)

(max-square-value-sum 10 11 2); => 221



;1.4 Заметим, что наша модель вычислений разрешает существование комбинаций,
; операторы которых - составные выражения. С помощью этого наблюдения опишите,
; как работает следующая процедура.

(define a-plus-abs-b  (lambda (a b)
  ((if (> b 0) + -) a b)
))

(a-plus-abs-b 1 -2); => 3
; Текущая процедура сначала вычисляет значение предиката, 
; далее вычисляется следствие или альтернатива 
; и применяется к операндам верхстоящей области видимости. 
; Вычисления в аппликативной форме практически не будут отличатся в
; подстановочной модели.



;1.5 Бен Битобор придумал тест для проверки интерпритатора на то, с каким порядком
;вычислений он работает, аппликативным или нормальным. Бен определяет такие две процедуры:

(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y
  ))

;(test 0 (p)); => при аппликативном порядке вычисления произойдет зависание,
; по причине того, что будет осуществленна попытка вычисления значения p,
; что приведет к бесконечной линейной рекурсии, при нормальном(ленивом) 
; порядке вычисления выведится 0, так как, попытки вычислить значение p не будет.



;1.6 Лиза П. Хакер не понимает, почему if должна быть особой формой. "Почему нельзя
;просто определить ее как обычную процедуру с помощью cond/" - спрашивает она. Лизина подруга Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию if.

(define (new-if  predicate then-clause else-clause)
  (cond (predicate then-clause)
  (else else-clause)
))

(define true 1)
(define falls 0)

(new-if (= 2 3) true falls); => 0
(new-if (= 1 1) true falls); => 1


(define (average x y)
  (/ (+ x y) 2))

(average 2 3); 5 => Вычисляет среднее арифметическое своих двух аргументов.


(define (improve guess x)
  (average guess (/ x guess)))

(improve 1 2); 1.5 Находит среднее арифметическое между догадкой и первым приближением,
; полученым путем деления x на догадку.


(define (abs x) 
  (cond ((> x 0) x)
    ((< x 0) (- x))
    (else 0))
)
(abs -1e-1111); => 0 Из интересного, приводит бесконечно(для языка) малые значения к 0, а
; бесконечно большие к вещественному inf.
;А вообще это просто общее определение модуля числа (Прим. унарный минус, меняет знак числа).


(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(good-enough? -1e-11111 4); => #t то есть true, находит разницу между квадратом догадки и
; x, возвращая логические истину, либо лож в завимости от отношения величин к заданому 
; пределу точности

;Что получится когда Лиза попытается использовать эту процедуру для вычисления квадратных корней? Обьясните.

(define (sqrt-iter guess x)
  (display guess) (newline)
  ;(new-if (good-enough? guess x) ; => Процедура зависнет...
  (if (good-enough? guess x)
    guess
    (sqrt-iter (improve guess x)
    x)))

(sqrt-iter 51 2); => 1.414215485584394
; Дело в том, что когда вычисляется не обернутая, а обычная условная конструкция
; игнорируется одна из двух результирующих ветвей, тем самым, либо возвращается догадка,
; либо следующая рекурсивная итерация процедуры, когда же условная конструкция находится
; в обернутке, то интерпритатор работающий аппликативно попытается вычислить все 3 значения 
; не зависимо от условия, тем самым не сработает условие остановки рекурсии и произойдет 
; бесконечный цикл.



;1.7 Ограничение приведенное в книге не подходит для малых чисел а так же для больших.
; Так же в реальном мире, арифметические операции всегда выполняются с погрешностью.
; Это делает наш тест неподходящим для больших чисел. Поясните данное утверждение,
; приведите примеры когда исходный вариант программы работает плохо.
; В качестве альтернативной реализации напишите программу которая считает результат
; подходящим когда изменение предположения между двумя итерациями много меньше предыдущего предполагаемого решения,
; то есть мы будем получать очень малое уточнение за все последующие операции.
; Попробуйте получить результат с помощью новой процедуры.

(define (new-good-enough? prev-guess new-guess)
  (< (abs (- new-guess prev-guess)) 0.001))


(define (new-sqrt-iter new-guess x (prev-guess 0))
  (displayln prev-guess) (newline)
  (if (new-good-enough? prev-guess new-guess)
    new-guess
    (new-sqrt-iter (improve new-guess x)
    x new-guess)))

(new-sqrt-iter  -10e+100 2.0); => 1.41421548581447 Прим. 1.значение по умолчанию работает 
; в racket среде, 2. Числовые параметры имеют вещественную запись для racket интерпритатора,
; так как, операции с целыми числами он отображает дробной записью.
; Ответы: 1. рациональныечисла и иррациональные числа мощность которых 
; около условной допустимой погрешности, при возведение в квадрат будут просто
; перескакивать точку локального минимума функции
; 2. Большие же значения будут иметь подобную проблему, перешагивая значение то вверх, то вниз
; не находя достаточно близкого значения, из-за большей разницы при двоичной конвертации числа.


