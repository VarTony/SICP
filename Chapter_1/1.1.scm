;1.1 Что выведут следующие выражения,

10 ;10

(+ 5 3 4) ;12

(- 9 1) ;8

(/ 6 2) ;3

(+ (* 5 5) (- 4 8)) ;21

(define a 3) ;3

(define b (+ a 1)) ;4

(+ a b (* b a)) ;19

(= a b)  ;#false

(if (and (> b a) (< b (* a b)))
      b
      a) ;4

(cond ((= a 4) 6)
      ((= b 4) (+ 1 7 a))
      (else 25)) ;12

(+ 2 (if (< b a) b a)) ;5

(* (cond((> a b) a)
        ((< a b) b)
        (else -1))
        (+ a 2)) ;20


;1.2 Перевести выражение в префиксную форму

(/ (+ 5 4 
        (- 2 
            (- 3 
                (+ 5 
                    (/ 4 5))))) 
    (* 3 
        (- 6 2) (- 2 7))) ; -0.23


;1.3 Определите процедуру, которая приниает в качестве аргументов три числа
; и возвращает сумму квадратов двух больших из них.

(define square (lambda (x) (* x x)))

(square 2)

(define max_square_value_sum (lambda (a b c) (
    cond ((and (< a b) (< a c)) (+ (square b) (square c)))
         ((and (< b a) (< b c)) (+ (square a) (square c)))
         (else (+ (square a) (square b)))))
)

(max_square_value_sum 10 11 2) ;=> 221


;1.4 Заметим, что наша модель вычислений разрешает существование комбинаций,
; операторы которых - составные выражения. С помощью этого наблюдения опишите,
; как работает следующая процедура.

(define a-plus-abs-b  (lambda (a b)
  ((if (> b 0) + -) a b)
))

(a-plus-abs-b 1 -2); => 3
; Текущая процедура сначала вычисляет значение предиката, 
; далее вычисляется следствие или альтернатива 
; и применяется к операндам верхстоящей области видимости. 
; Вычисления в аппликативной форме практически не будут отличатся в
; подстановочной модели.


;1.5 

(define (p) (p))

(define (test x y)
  (if (= x 0)
    0
    y
  ))

(test 0 (p)); => при аппликативном порядке вычисления произойдет зависание,
; по причине того, что будет осуществленна попытка вычисления значения p,
; что приведет к бесконечной линейной рекурсии, при нормальном(ленивом) 
; порядке вычисления выведится 0, так как, попытки вычислить значение p не будет.

